<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chatzi - Chat</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body class="fullChatPage">
  <div class="container">
    <div class="topbar">
      <div class="brand">ðŸ’¬ Chatzi</div>
      <div class="badge">Press <b>Esc</b> to skip</div>
    </div>

    <div class="card">
      <div class="header">
        <div>
          <p class="title">Chat</p>
          <div class="sub">
            You: <b id="myName"></b>
            <span id="myGender" style="color:#6b7280;"></span>
          </div>
        </div>

        <div class="status">
          <span id="dot" class="dot wait"></span>
          <span id="status">Preparing...</span>
        </div>
      </div>

      <div id="messages" class="chatArea"></div>

      <div class="footer">
        <input id="msgInput" class="input" placeholder="Type a message..." />
        <button id="sendBtn" class="btnPrimary" disabled>Send</button>
        <button id="nextBtn" class="btn">New Chat</button>
      </div>
    </div>
  </div>

<script>
const BACKEND = "https://chatzi-backend.onrender.com";

const params = new URLSearchParams(window.location.search);
const myName = params.get("name") || "Anonymous";
const myGender = params.get("gender") || "Other";

document.getElementById("myName").textContent = myName;
document.getElementById("myGender").textContent = `(${myGender})`;

let socket = null;
let currentRoom = null;

const statusEl = document.getElementById("status");
const dotEl = document.getElementById("dot");
const messagesEl = document.getElementById("messages");
const inputEl = document.getElementById("msgInput");
const sendBtn = document.getElementById("sendBtn");

function setStatus(text, mode){
  statusEl.textContent = text;
  dotEl.className = "dot " + mode;
}

function addMsg(text, type="system"){
  const wrap = document.createElement("div");
  wrap.className = "msg " + type;
  const bubble = document.createElement("div");
  bubble.className = "bubble";
  bubble.textContent = text;
  wrap.appendChild(bubble);
  messagesEl.appendChild(wrap);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function timeoutFetch(url, ms){
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), ms);
  return fetch(url, { signal: controller.signal, cache: "no-store" })
    .finally(() => clearTimeout(t));
}

function loadSocketIoCdn(){
  return new Promise((resolve, reject) => {
    const s = document.createElement("script");
    s.src = "https://cdn.socket.io/4.7.5/socket.io.min.js";
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

// âœ… retry wake for up to 90 seconds
async function wakeServerWithRetry(){
  const start = Date.now();
  let attempt = 0;

  while (Date.now() - start < 90000) {
    attempt++;
    const secs = Math.floor((Date.now() - start)/1000);
    setStatus(`Waking serverâ€¦ (${secs}s)`, "wait");
    if (attempt === 1) addMsg("Waking serverâ€¦ first time can take up to ~1 min on free hosting.");

    try {
      // give Render more time (30 seconds per attempt)
      const res = await timeoutFetch(BACKEND + "/health", 30000);
      if (res.ok) return true;
    } catch (e) {
      // ignore and retry
    }

    // wait 2 seconds then retry
    await new Promise(r => setTimeout(r, 2000));
  }
  return false;
}

async function startConnection(){
  setStatus("Preparingâ€¦", "wait");

  const ok = await wakeServerWithRetry();
  if (!ok) {
    setStatus("Server not responding. Try again.", "off");
    addMsg("âš ï¸ Backend still not responding after 90s. This is hosting sleep/network. Press New Chat to retry.");
    return;
  }

  setStatus("Loading chat engineâ€¦", "wait");
  try {
    await loadSocketIoCdn();
  } catch {
    setStatus("Socket CDN blocked. Try different network.", "off");
    addMsg("âš ï¸ socket.io CDN didnâ€™t load. Try hotspot / different Wi-Fi.");
    return;
  }

  setStatus("Connectingâ€¦", "wait");
  socket = io(BACKEND, { transports: ["websocket","polling"], timeout: 20000 });

  socket.on("connect", () => {
    setStatus("Finding strangerâ€¦", "wait");
    socket.emit("register_profile", { name: myName, gender: myGender });
    socket.emit("find_match");
  });

  socket.on("waiting", () => {
    setStatus("Waiting for a strangerâ€¦", "wait");
    sendBtn.disabled = true;
  });

  socket.on("matched", ({ room, partner }) => {
    currentRoom = room;
    messagesEl.innerHTML = "";
    setStatus(`${partner.gender} connected âœ…`, "ok");
    addMsg("You are now chatting with a stranger. Be respectful ðŸ™‚");
    sendBtn.disabled = false;
    inputEl.focus();
  });

  socket.on("receive_message", (msg) => addMsg(msg, "them"));

  socket.on("partner_left", () => {
    addMsg("âš ï¸ Stranger left the chat");
    sendBtn.disabled = true;
    setStatus("Stranger disconnected", "off");
  });

  socket.on("connect_error", (e) => {
    setStatus("Socket connect failed. New Chat to retry.", "off");
    addMsg("âš ï¸ Socket connect failed (CORS/origin/network). Press New Chat.", "system");
    sendBtn.disabled = true;
  });
}

function skipChat(){
  messagesEl.innerHTML = "";
  currentRoom = null;
  sendBtn.disabled = true;

  if (!socket || socket.disconnected) {
    startConnection();
    return;
  }

  setStatus("Finding new strangerâ€¦", "wait");
  socket.emit("find_match");
}

document.addEventListener("keydown", e => {
  if (e.key === "Escape") skipChat();
});

sendBtn.onclick = () => {
  const msg = inputEl.value.trim();
  if(!msg || !currentRoom || !socket || socket.disconnected) return;
  addMsg(msg, "me");
  socket.emit("send_message", { room: currentRoom, message: msg });
  inputEl.value = "";
};

inputEl.addEventListener("keydown", e => {
  if(e.key === "Enter") sendBtn.click();
});

document.getElementById("nextBtn").onclick = skipChat;

setTimeout(startConnection, 100);
</script>
</body>
</html>
